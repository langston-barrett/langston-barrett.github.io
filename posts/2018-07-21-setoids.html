<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>siddharthist.github.io - A quick tutorial on setoids in Coq</title>
        <link rel="stylesheet" href="../css/mine.css" />
        <link rel="stylesheet" href="../css/syntax.css" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115381167-1"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-115381167-1');
        </script>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">siddharthist.github.io</a>
            </div>
            <nav>
                <a href="../about.html">About</a>
            </nav>
        </header>

        <main role="main">
            <!-- <h1>A quick tutorial on setoids in Coq</h1> -->
            <article>
    <section class="header">
        Posted on July 21, 2018
        
    </section>
    <section>
        <h1 id="a-quick-tutorial-on-setoids-in-coq">A quick tutorial on setoids in Coq</h1>
<p>A setoid is a type <code>T</code> and an <a href="https://coq.inria.fr/library/Coq.Classes.RelationClasses.html#Equivalence"><code>equivalence</code></a> <a href="https://coq.inria.fr/library/Coq.Relations.Relation_Definitions.html#relation"><code>relation</code></a> <code>(==) : T -&gt; T -&gt; Prop</code>. Coq has some built-in automation facilities for working with setoids that can make your life a lot easier.</p>
<h2 id="building-a-setoid">Building a setoid</h2>
<p>Let’s suppose we wanted to implement a quick-and-dirty version of finite sets on some type <code>A</code>. One option is to use <code>list A</code>, but lists have two properties that get in the way: ordering and duplication. Building a <code>Setoid</code> allows us to abstract away these features, and consider two lists equivalent if they have the same elements.</p>
<pre class="coq"><code>Context {A : Type}.

Definition equiv_list (l1 l2 : list A) : Prop :=
  ∀ a : A, In a l1 &lt;-&gt; In a l2.</code></pre>
<p>To register our new equivalence with Coq and reap the benefits of automation, we make <code>list A</code> an instance of the <code>Setoid</code> <a href="https://softwarefoundations.cis.upenn.edu/draft/qc-current/Typeclasses.html">typeclass</a>:</p>
<pre class="coq"><code>Instance ListSetoid : Setoid (list A) :=
  { equiv := equiv_list }.
Proof.
  split.</code></pre>
<p>At this point, we’re dropped into proof mode and our goal is to prove that <code>equiv_list</code> is an equivalence relation. To see the full proof, see <a href="https://gist.github.com/siddharthist/9462a99ebb6fb7acb4ddbfd6c3e66b9c">the Coq source for this post</a> (we use some setoid-related automation to prove this goal).</p>
<p>Immediately, we gain access to a few tactics that work for normal equality, like <a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.reflexivity"><code>reflexivity</code></a>, <a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.symmetry"><code>symmetry</code></a> (plus <code>symmetry in [...]</code>), and <a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.transitivity"><code>transitivity</code></a>.</p>
<h2 id="setoid_rewrite"><code>setoid_rewrite</code></h2>
<p>The #1 benefit to using setoids is access to the <code>setoid_rewrite</code> tactic. Rewriting is one of the most powerful features of the tactic language, and using setoids allows us to expand its reach.</p>
<p>Suppose we have <code>l1 l2 : list A</code>. If we have <code>l1 = l2</code> (where <code>=</code> is Coq’s built-in equality), we can replace <code>l1</code> with <code>l2</code> in all contexts:</p>
<pre class="coq"><code>Lemma hd_eq (l1 l2 : list A) : l1 = l2 -&gt; hd l1 = hd l2.
Proof.
  intros l1eql2.
  now rewrite l1eql2.
Qed.</code></pre>
<p>This isn’t true if we just know <code>l1 == l2</code> (where <code>==</code> is <a href="https://coq.inria.fr/refman/user-extensions/syntax-extensions.html">notation</a> for <code>list_equiv</code>). However, there are certain contexts in which they are interchangeable. Suppose further that <code>A</code> has decidable equality, and consider the following <code>remove</code> function:</p>
<pre class="coq"><code>Context {deceq : ∀ x y : A, {x = y} + {x ≠ y}}.

Fixpoint remove (x : A) (lst : list A) : list A :=
  match lst with
  | nil =&gt; nil
  | cons y ys =&gt;
    match deceq x y with
    | left  _ =&gt; remove x ys
    | right _ =&gt; y :: remove x ys
    end
  end.</code></pre>
<p>Since this removes <em>all</em> occurrences of <code>x</code> in <code>lst</code>, we should be able to prove</p>
<pre class="coq"><code>∀ x l1 l2, l1 == l2 -&gt; remove x l1 = remove x l2</code></pre>
<p>We state this lemma a bit oddly:</p>
<pre class="coq"><code>Instance removeProper : Proper (eq ==&gt; equiv ==&gt; equiv) remove.</code></pre>
<p>This concisely states “given two equal inputs <code>x y : A</code> and two equivalent lists <code>l1 l2 : list A</code>, <code>remove x l1</code> is equivalent to <code>remove y l2</code>”. In other words, <code>remove</code> respects equality on <code>A</code> (trivially – every Coq function respects equality) and the equivalence relation <code>==</code> (AKA <code>equiv</code>) on <code>list A</code>.</p>
<p>Once we have an <code>Instance</code> of <code>Proper</code>, we can use <code>setoid_rewrite</code> to replace replace <code>remove x l1</code> with <code>remove x l2</code>, even when they appear nested in the goal statement:</p>
<pre class="coq"><code>Instance revProper : Proper (equiv ==&gt; equiv) (@rev A).
Proof.
  [...]
Qed.

Lemma remove_rev_remove {a b : A} {l1 l2 : list A} : 
  l1 == l2 -&gt; rev (remove a l1) == rev (remove a l2).
Proof.
  intros H.
  now setoid_rewrite H.
Qed.</code></pre>
<p>We can even compose <code>Proper</code> instances automatically:</p>
<pre class="coq"><code>Require Import Coq.Program.Basics.
Local Open Scope program_scope.

Instance rev_remove_Proper : ∀ a, Proper (equiv ==&gt; equiv) (@rev A ∘ remove a).
Proof.
  apply _.
Qed.</code></pre>
<p>The benefits of setoid rewriting continue to increase with the complexity of the goal.</p>
    </section>
</article>

        </main>
    </body>
</html>
